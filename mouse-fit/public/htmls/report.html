<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mouse-Fit — Measurement Report</title>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@500;700&display=swap" rel="stylesheet" />
<link rel="stylesheet" href="/neon.css" />
<style>
:root{
  --bg:#05060a; --fg:#eaf0ff; --sub:#a6b0c8; --border:rgba(255,255,255,.10);
  --g1:#7c3aed; --g2:#22d3ee; --g3:#a78bfa;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; font-family:Lexend, system-ui, Arial;
  background:
    radial-gradient(1100px 560px at 90% 6%,rgba(48,124,255,.18),transparent 60%),
    linear-gradient(135deg,#05060a,#071022 58%,#0a1c3a 100%);
  color:var(--fg);
}

/* ===== ultra-thin neon page frame ===== */
.page-frame{
  position:fixed; inset:6px; pointer-events:none; z-index:1000;
  border-radius:16px;
  border:1px solid rgba(167,139,250,.35);
  box-shadow:inset 0 0 0 1px rgba(34,211,238,.18), 0 0 18px rgba(124,58,237,.18);
}

/* ===== HERO layout ===== */
.hero{
  max-width:1200px; margin:24px auto 0; padding:0 20px;
  display:grid; grid-template-columns: minmax(280px,520px) 1fr; gap:28px; align-items:center;
  position:relative;
}
@media (max-width:980px){ .hero{grid-template-columns:1fr; gap:18px} }

.blob{
  aspect-ratio: 4/3; border-radius:18px; position:relative; overflow:hidden;
  border:1px solid rgba(255,255,255,.08);
  background:
    radial-gradient(120% 120% at 20% 10%, rgba(124,58,237,.45), transparent 40%),
    radial-gradient(80% 80% at 80% 20%, rgba(34,211,238,.35), transparent 45%),
    radial-gradient(100% 120% at 60% 80%, rgba(167,139,250,.35), transparent 55%),
    #0b0f1c;
  box-shadow: 0 30px 80px rgba(0,0,0,.45), inset 0 0 60px rgba(255,255,255,.05);
}
.blob::after{
  content:""; position:absolute; inset:0;
  background: radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.12), transparent 55%);
  mix-blend-mode: screen; pointer-events:none;
}

/* snapshot sits above blob, blurred until reveal */
#snapshot{
  position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
  display:block; transition:filter .3s ease, opacity .3s ease;
}

/* Right text block */
.report-copy{ position:relative; padding:8px 6px 8px 6px }
.h1{ font-size:28px; margin:8px 0 8px }
.kicker{ letter-spacing:.16em; font-size:12px; opacity:.9; color:#cfe1ff; margin-bottom:8px }
.ghost{
  position:absolute; right:6px; top:-6px; font-size:96px; line-height:1;
  color:transparent; -webkit-text-stroke:1px rgba(255,255,255,.06);
  text-stroke:1px rgba(255,255,255,.06); pointer-events:none; user-select:none;
}
.stats{  margin-top:8px; display:grid; gap:6px; transition:filter .25s ease, opacity .25s ease; }
.stats .row{ display:flex; gap:10px; align-items:center; font-size:14px }
.pill{padding:6px 10px;border-radius:999px;background:#0f1524;border:1px solid #2a2f40;font-size:12px;color:#cfe9f6}

/* Grip thumbs */
.grip-thumbs{display:none; gap:10px; margin-top:12px}
.grip-thumbs img{width:84px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #2a2f40;background:#0b0b0f;transition:filter .25s ease}

/* Action buttons — neon */
.btn{background:#101626;color:var(--fg);border:1px solid #223049;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
.btn.neon{background:linear-gradient(90deg,var(--g1),var(--g2),var(--g3));border-color:transparent;box-shadow:0 0 18px rgba(124,58,237,.35),0 0 28px rgba(34,211,238,.22)}
.btn.neon:hover{filter:brightness(1.05)}
.reveal-bar{ display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap }

/* tiny helper for empty state */
.empty{opacity:.8;font-size:14px}

/* === Reveal/Hide blur states (PERSISTENT) === */
body[data-revealed="false"] #snapshot{ filter:blur(18px) saturate(.9) }
body[data-revealed="true"]  #snapshot{ filter:none }
body[data-revealed="false"] .stats,
body[data-revealed="false"] .grip-thumbs img{ filter:blur(12px) }
body[data-revealed="true"]  .stats,
body[data-revealed="true"]  .grip-thumbs img{ filter:none }

/* ===== AI REPORT SECTION (embedded) ===== */
.ai-wrap{ max-width:1200px; margin:30px auto 90px; padding:0 20px }
.ai-title{ font-size:22px; margin:10px 0 6px }
.ai-sub{ color:var(--sub); margin:0 0 10px; font-size:13px }
.controls{ display:flex; gap:10px; flex-wrap:wrap; margin: 10px 0 6px; }
.status{ font-size:12px; color:var(--sub); min-height:18px; white-space:pre-wrap }

.ai-card{
  margin-top: 14px; border: 1px solid var(--border); border-radius: 14px;
  padding: 14px; background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.04));
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
}
.ai-card h3{ margin:0 0 6px; font-size:18px }
.para{ white-space: pre-wrap; line-height: 1.5; }
.hr{ height:1px; background: var(--border); margin: 10px 0; opacity:.7; }

.grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(230px,1fr)); gap:12px; margin-top:12px }
.chip{
  position:relative; overflow:hidden;
  border:1px solid rgba(255,255,255,.14); border-radius:16px; padding:12px 14px;
  font-weight:700; color:#fff; min-height:78px; background: rgba(255,255,255,.06);
}
.chip > *{ position:relative; z-index:1 }
.chip .meta{ font-weight:600; color:var(--sub); margin-top:6px }
.chip .pct{ position:absolute; right:10px; top:10px; font-weight:800 }

.bg-palm::before, .bg-claw::before, .bg-tip::before{
  content:""; position:absolute; inset:0; opacity:.5; z-index:0; pointer-events:none;
}
.bg-palm::before { background: linear-gradient(135deg, rgba(82,0,163,1), rgba(167,94,246,1)); }
.bg-claw::before { background: linear-gradient(135deg, rgba(14,98,255,1), rgba(104,169,255,1)); }
.bg-tip::before  { background: linear-gradient(135deg, rgba(214,31,105,1), rgba(255,139,197,1)); }
</style>
<script src="/js/nav.js" defer></script>
</head>
<body data-revealed="false">

<div class="page-frame" aria-hidden="true"></div>


<!-- HERO -->
<section class="hero">
  <!-- Left: neon blob with snapshot on top -->
  <div class="blob">
    <img id="snapshot" alt="Hand snapshot">
  </div>

  <!-- Right: clean text block -->
  <div class="report-copy">
    <div class="ghost">REPORT</div>
    <div class="kicker">YOUR RESULTS</div>
    <div class="h1">Hand measurement & grip insight</div>

    <div class="stats" id="measurements">
      <div class="row"><strong>Hand length:</strong> <span id="handLength">—</span> cm</div>
      <div class="row"><strong>Palm width:</strong> <span id="handWidth">—</span> cm</div>
      <div class="row"><strong>Hand size category:</strong> <span id="handSize">—</span></div>
      <div class="row"><strong>Suggested grip style(s):</strong> <span id="suggestedGrip">—</span></div>
      <div class="row"><span id="gripPill" class="pill">Grip: not checked</span></div>
    </div>

    <div id="gripThumbs" class="grip-thumbs">
      <img id="gripTop"   alt="Top view">
      <img id="gripRight" alt="Right view">
      <img id="gripLeft"  alt="Left view">
    </div>

    <div class="reveal-bar">
      <button id="toggleReveal" class="btn neon">Reveal measurements</button>
      <a href="./grip.html" class="btn neon">Open Grip Checker</a>
      <button id="redoBtn" class="btn neon" onclick="location.href='measure.html'">Redo test</button>
    </div>
  </div>
</section>

<!-- =========================================================
     AI REPORT (embedded) – replaces old recs section entirely
========================================================= -->
<section class="ai-wrap">
  <div class="ai-title">AI Recommendations</div>
  <p class="ai-sub">Ranked per grip based on your measurements & our RAG-augmented matching rules.</p>

  <div class="controls">
    <button class="btn neon" id="btn-generate">Generate AI Report</button>
    <button class="btn" id="btn-copy">Copy Summary</button>
  </div>
  <div class="status" id="status"></div>

  <div class="ai-card">
    <h3>Two-Paragraph Summary</h3>
    <div id="p1" class="para"></div>
    <div class="hr"></div>
    <div id="p2" class="para"></div>
  </div>

  <div class="ai-card">
    <h3>Palm Grip</h3>
    <div id="grid-palm" class="grid"></div>
  </div>

  <div class="ai-card">
    <h3>Claw Grip</h3>
    <div id="grid-claw" class="grid"></div>
  </div>

  <div class="ai-card">
    <h3>Fingertip Grip</h3>
    <div id="grid-tip" class="grid"></div>
  </div>
</section>

<script>
/* ============================================================
   STORAGE: keep data by default. Only clear if you open with
   /report.html?fresh=1  (useful for debugging a clean slate)
============================================================ */
(() => {
  const params = new URLSearchParams(location.search);
  if (params.get('fresh') !== '1') return;
  try {
    for (const k of Object.keys(localStorage))
      if (k.startsWith('mousefit:') || k.startsWith('mf:')) localStorage.removeItem(k);
    for (const k of Object.keys(sessionStorage))
      if (k.startsWith('mousefit:') || k.startsWith('mf:')) sessionStorage.removeItem(k);
  } catch {}
})();

/* ============================================================
   COMPAT SHIM: read either mousefit:* or mf:* keys and normalize
============================================================ */
function getFirst(keys){ for (const k of keys){ const v=localStorage.getItem(k); if(v!=null && v!=="") return v; } return null; }
function getJSON(keys){ const raw=getFirst(keys); if(!raw) return null; try{return JSON.parse(raw);}catch{return null;} }
function setIfMissing(dst,src){ const v=localStorage.getItem(src); if(v && !localStorage.getItem(dst)) localStorage.setItem(dst,v); }
setIfMissing('mousefit:measure','mf:measure');
setIfMissing('mousefit:recs','mf:recs');
setIfMissing('mousefit:snapshot','mf:snapshot');
setIfMissing('mousefit:grip_view_top','mf:grip_view_top');
setIfMissing('mousefit:grip_view_right','mf:grip_view_right');
setIfMissing('mousefit:grip_view_left','mf:grip_view_left');
setIfMissing('mousefit:grip_result','mf:grip_result');

function normalizeMeasure(m){
  if(!m) return {};
  const len_mm = m.len_mm ?? m.length_mm ?? (m.len_cm ? Math.round(Number(m.len_cm)*10) : undefined);
  const wid_mm = m.wid_mm ?? m.width_mm ?? (m.wid_cm ? Math.round(Number(m.wid_cm)*10) : undefined);
  const out = { ...m };
  if(len_mm!=null){ out.len_mm=Number(len_mm); out.len_cm=(Number(len_mm)/10).toFixed(1); }
  if(wid_mm!=null){ out.wid_mm=Number(wid_mm); out.wid_cm=(Number(wid_mm)/10).toFixed(1); }
  return out;
}

const MF = {
  measure: normalizeMeasure(getJSON(['mousefit:measure','mf:measure'])),
  recs:    getJSON(['mousefit:recs','mf:recs']) || {},
  snapshot:getFirst(['mousefit:snapshot','mf:snapshot']),
  grips: {
    top:   getFirst(['mousefit:grip_view_top','mf:grip_view_top']),
    right: getFirst(['mousefit:grip_view_right','mf:grip_view_right']),
    left:  getFirst(['mousefit:grip_view_left','mf:grip_view_left']),
    result:getJSON(['mousefit:grip_result','mf:grip_result']) || {}
  }
};
console.log('[MF:report] loaded', MF);

/* ============================================================
   REVEAL / HIDE (blur by default with persistence)
============================================================ */
(function restoreRevealToggle(){
  const REVEAL_KEY = 'mousefit:revealed'; // "1" or "0"
  const btn = document.getElementById('toggleReveal');
  if (!btn) return;

  const setReveal = (flag) => {
    document.body.setAttribute('data-revealed', flag ? 'true' : 'false');
    btn.textContent = flag ? 'Hide measurements' : 'Reveal measurements';
    try { localStorage.setItem(REVEAL_KEY, flag ? '1' : '0'); } catch {}
  };

  // Initial state (default hidden)
  let initial = false;
  try { initial = localStorage.getItem(REVEAL_KEY) === '1'; } catch {}
  setReveal(initial);

  btn.addEventListener('click', () => {
    const current = document.body.getAttribute('data-revealed') === 'true';
    setReveal(!current);
  });
})();

/* ============================================================
   RENDER SNAPSHOT + NUMBERS + GRIP
============================================================ */
(function render(){
  // snapshot
  const img = document.getElementById('snapshot');
  if (MF.snapshot) img.src = MF.snapshot; else img.style.opacity = '0';

  // numbers
  const m = MF.measure || {};
  if (m.len_cm) document.getElementById('handLength').textContent = m.len_cm;
  if (m.wid_cm) document.getElementById('handWidth').textContent  = m.wid_cm;

  const rec = MF.recs || {};
  if (rec.size) document.getElementById('handSize').textContent = rec.size;
  let gripSuggestion = "";
  const size = rec.size;
  if (size === "small") gripSuggestion = "Claw often works well for small hands; palm can also be comfy.";
  else if (size === "medium") gripSuggestion = "Palm is versatile; try claw or fingertip based on preference.";
  else if (size === "large" || size === "xlarge") gripSuggestion = "Fingertip may feel natural; palm can still be comfortable.";
  else gripSuggestion = "Any grip style can work — pick what feels most natural.";
  document.getElementById('suggestedGrip').textContent = gripSuggestion;

  // thumbs
  if (MF.grips.top || MF.grips.right || MF.grips.left){
    const box = document.getElementById('gripThumbs'); box.style.display = 'flex';
    if (MF.grips.top)   document.getElementById('gripTop').src   = MF.grips.top;
    if (MF.grips.right) document.getElementById('gripRight').src = MF.grips.right;
    if (MF.grips.left)  document.getElementById('gripLeft').src  = MF.grips.left;
  }
  const r = MF.grips.result || {};
  const grip = (r.grip || r.local_guess?.grip || "").toLowerCase();
  const conf = Math.round(100 * (r.confidence ?? r.local_guess?.confidence ?? 0));
  if (grip) document.getElementById('gripPill').textContent = conf ? `Grip: ${grip} (${conf}%)` : `Grip: ${grip}`;
})();
</script>

<!-- Load mice data -->
<script src="/js/mice.js"></script>

<script type="module">
/* ============================================================
   Embedded AI report logic (formerly ai-report.html)
============================================================ */
const $status = document.getElementById("status");
const $p1 = document.getElementById("p1");
const $p2 = document.getElementById("p2");
const setStatus = (m)=>($status.textContent = m || "");

// ---- profile from page ----
function scrapeProfileFromPage(){
  const mmTextToMm = (txt) => {
    const t = String(txt||"").toLowerCase();
    let m = t.match(/(\d+(?:\.\d+)?)\s*mm\b/); if (m) return +m[1];
    m = t.match(/(\d+(?:\.\d+)?)\s*cm\b/); if (m) return Math.round(+m[1]*10);
    m = t.match(/(\d+(?:\.\d+)?)/); if (!m) return undefined;
    const v = +m[1]; return v>=30 ? v : Math.round(v*10);
  };

  const profile = {};
  try {
    const ms = window.MF?.measure;
    if (ms?.len_mm) profile.length_mm = +ms.len_mm;
    if (ms?.wid_mm) profile.width_mm  = +ms.wid_mm;
  } catch {}
  if (!profile.length_mm) profile.length_mm = mmTextToMm(document.getElementById("handLength")?.textContent);
  if (!profile.width_mm)  profile.width_mm  = mmTextToMm(document.getElementById("handWidth")?.textContent);

  const g = window.MF?.grips?.result?.grip;
  if (g) profile.grip = String(g).toLowerCase();

  return profile;
}

const profile = scrapeProfileFromPage();
let handLength = profile.length_mm || 180;
let handWidth  = profile.width_mm  || 90;

// ---- pull mice from /js/mice.js ----
async function loadMice(){
  const g =
    (Array.isArray(window.mice) && window.mice) ||
    (Array.isArray(window.MICE) && window.MICE) ||
    (Array.isArray(window.MOUSE_DB) && window.MOUSE_DB) ||
    null;
  if (g) return g;
  try{
    const mod = await import("/js/mice.js");
    if (Array.isArray(mod?.default)) return mod.default;
    if (Array.isArray(mod?.mice)) return mod.mice;
    if (Array.isArray(mod?.MICE)) return mod.MICE;
  }catch{}
  throw new Error("mice.js not found or not an array");
}

// ---- normalize mice ----
const toName = (m)=> m.name || [m.brand||m.make||m.maker||"", m.model||m.title||""].filter(Boolean).join(" ").trim() || "Unknown";
const getDims = (m)=>{
  let L = m.length ?? m.length_mm ?? m.L ?? m.dimL;
  let W = m.width  ?? m.width_mm  ?? m.W ?? m.dimW;
  let H = m.height ?? m.height_mm ?? m.H ?? m.dimH;
  if ((!L || !W || !H) && m.spec){
    const dm = String(m.spec).match(/(\d+(?:\.\d+)?)\s*[×x]\s*(\d+(?:\.\d+)?)\s*[×x]\s*(\d+(?:\.\d+)?)/);
    if (dm){ L=+dm[1]; W=+dm[2]; H=+dm[3]; }
  }
  return { L:+L||0, W:+W||0, H:+H||0 };
};
const getWeight = (m)=>{
  let g = m.weight ?? m.weight_g;
  if (!g && m.spec){
    const mw = String(m.spec).match(/(\d+(?:\.\d+)?)\s*g\b/i);
    if (mw) g = +mw[1];
  }
  return +g || 0;
};
const getShape = (m)=>{
  const s = (m.shape||m.type||"").toString().toLowerCase();
  if (s.includes("ergo")) return "ergonomic";
  if (s.includes("sym") || s.includes("ambi")) return "symmetrical";
  return s || "symmetrical";
};
const slug = (s)=> String(s).toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-|-$|/g,"");

function normalize(m){
  const name = toName(m);
  const {L,W,H} = getDims(m);
  const weight = getWeight(m);
  const shape = getShape(m);
  const id = m.id || slug(name);
  return { id, name, length:L, width:W, height:H, weight, shape };
}

// ---- scoring (latest spec) ----
const idealRatio = { palm: 0.70, claw: 0.62, fingertip: 0.55 };  // exact, in mm against handLength
const weightBase = { palm: 65, claw: 65, fingertip: 45 };        // grams
const heavyKnee  = 81;                                           // steep penalties >81g

// RAG flag helpers
function collectFlags(ranked){
  const map = new Map();
  for (const r of ranked||[]){
    map.set(r.id, (Array.isArray(r.flags)? r.flags.map(x=>String(x).toLowerCase()) : []));
  }
  return map;
}
const hasAny = (flags, arr)=> arr.some(a=> flags.includes(a));

// 40% Grip match: exact target length; −1 point per mm error
function gripSubscore(mouse, grip){
  const Lm = mouse.length||0;
  const target = idealRatio[grip] * handLength;
  const diffMM = Math.abs(Lm - target);
  return Math.max(0, 100 - diffMM);
}

// 20% Weight: baseline 65/65/45; steeper >81g; no light bonus
function weightSubscore(mouse, grip){
  const w = mouse.weight||0;
  const base = weightBase[grip];
  if (!w) return 60;
  if (w <= base) return 100;
  const over = w - base;
  const slope = (grip==="fingertip") ? 2.0 : (grip==="claw" ? 1.4 : 1.0);
  let penalty = over * slope;
  if (w > heavyKnee){
    const extra = w - heavyKnee;
    const extraSlope = (grip==="fingertip") ? 2.5 : (grip==="claw" ? 1.5 : 1.0);
    penalty += extra * extraSlope;
  }
  return Math.max(0, 100 - penalty);
}

// 40% Hump: geometry + flags
function humpSubscore(mouse, grip, flags){
  const H = mouse.height||0;
  let s = 70; // neutral base
  const f = flags || [];

  const highHumpKeys = ["high_hump","tall_hump","large_hump","huge_hump"];
  const rearHumpKeys = ["rear_hump","back_hump","rear-biased","back-biased"];
  const inclinedKeys = ["inclined_side","angled_side","tilted_side"];

  const hasHigh = (f || []).some(x => highHumpKeys.includes(x));
  const hasRear = (f || []).some(x => rearHumpKeys.includes(x));
  const hasInclined = (f || []).some(x => inclinedKeys.includes(x));

  if (grip === "palm") {
    // Neutral to high/rear; deduct for low/flat
    if (H <= 40) s -= 20;
  } else if (grip==="claw"){
        if (42>= H >= 36) s += 15;
        if (H >= 42) s -= 30;            // claw better with huge back hump (height proxy)
        if (hasHigh) s += 15;
        if (hasRear) s += 12;
        // inclined side is better for claw (bonus is applied later too)
        if (hasAny(f, inclinedKeys)) s += 3;
  } else { // fingertip
    if (H >= 40) s -= 30;
    if (H <= 36) s += 10;
    if (hasHigh) s -= 15;
    if (hasRear) s -= 8;
  }
  return Math.max(0, Math.min(100, s));
}

// Shape: only fingertip cares (ergo = −50)
function shapePenalty(mouse, grip){
  if (grip!=="fingertip") return 0;
  return (mouse.shape==="ergonomic") ? -50 : 0;
}

// Extra post-weighting bonus for claw if inclined side
function extraBonus(flags, grip){
  if (grip!=="claw") return 0;
  const inclinedKeys = ["inclined_side","angled_side","tilted_side"];
  return hasAny(flags||[], inclinedKeys) ? 3 : 0;
}

// Overall score
function overallScore(mouse, grip, flags){
  const gripS   = gripSubscore(mouse, grip);
  const weightS = weightSubscore(mouse, grip);
  const humpS   = humpSubscore(mouse, grip, flags);
  let total = 0.40*gripS + 0.20*weightS + 0.40*humpS;
  total += shapePenalty(mouse, grip);  // fingertip ergo -50
  total += extraBonus(flags, grip);    // claw incline +3
  return Math.max(0, total); // allow >100 via post-bonus; don't clamp upper bound
}

// RAG flags fetch (non-fatal if fails)
async function fetchFlags(mice){
  try{
    const candidates = mice.map(m=>({ id:m.id, brand:"", model:m.name }));
    const body = { profile: { grip: profile.grip||null, length_mm: handLength, width_mm: handWidth }, candidates };
    const r = await fetch("/api/rerank", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
    const data = await r.json();
    if (!r.ok) throw new Error(data.error || "rerank failed");
    return collectFlags(data.ranked||[]);
  }catch(e){
    console.warn("RAG flags unavailable:", e.message||e);
    return new Map();
  }
}

// Render helpers
function chipClass(grip){ return grip==="palm"?"bg-palm":grip==="claw"?"bg-claw":"bg-tip"; }
function renderGrid(el, items, grip){
  el.innerHTML = "";
  items.forEach((it, idx)=>{
    const div = document.createElement("div");
    div.className = `chip ${chipClass(grip)} ${idx===0?"best":""}`;
    const shapeName = it.shape ? it.shape.charAt(0).toUpperCase()+it.shape.slice(1) : "N/A";
    div.innerHTML = `
      <div class="pct">${Math.round(it.score)}%</div>
      <div>${it.name}</div>
      <div class="meta">Weight: ${it.weight||"?"} g, Shape: ${shapeName}</div>
    `;
    el.appendChild(div);
  });
}

function sanitizeReport(text){
  const [a0="", b0=""] = (text||"").trim().split(/\n\s*\n/);
  const strip = s => s.split(/\n+/).filter(line=>
    !/\b(hand|palm)\s*(length|width|size)\b/i.test(line) &&
    !/\b(colorway|colorways|color|edition)\b/i.test(line)
  ).join("\n");
  return [strip(a0).trim(), strip(b0).trim()];
}

async function generateReport(){
  try{
    setStatus("Loading mice…");
    const baseRaw = await loadMice();
    const mice = baseRaw.map(normalize).filter(m=> m.length && m.width && m.height);
    if (!mice.length){ setStatus("No mice with dimensions found."); return; }

    setStatus("Reading flags…");
    const flagMap = await fetchFlags(mice);

    setStatus("Scoring…");
    const grips = ["palm","claw","fingertip"];
    const results = {};
    for (const g of grips){
      const list = mice.map(m=>{
        const flags = flagMap.get(m.id) || [];
        return { ...m, flags, score: overallScore(m, g, flags) };
      }).sort((a,b)=> (b.score - a.score)).slice(0, 12);
      results[g] = list;
    }

    renderGrid(document.getElementById("grid-palm"), results.palm, "palm");
    renderGrid(document.getElementById("grid-claw"), results.claw, "claw");
    renderGrid(document.getElementById("grid-tip"),  results.fingertip, "fingertip");

    // Two-paragraph summary (optional)
    setStatus("Summarizing…");
    try{
      const body = { profile, candidates: mice.map(({id,name})=>({id,brand:"",model:name})) };
      const r = await fetch("/api/report",{ method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
      const txt = await r.text(); let data; try{ data=JSON.parse(txt);}catch{ data={raw:txt};}
      if (!r.ok) throw new Error(data.error || data.raw || r.statusText);
      const [a,b] = sanitizeReport(data.report||"");
      $p1.textContent = a; $p2.textContent = b;
      setStatus("");
    }catch(e){
      $p1.textContent = ""; $p2.textContent = "";
      setStatus(""); // silent if /api/report not configured
    }
  } catch (e) {
    console.error(e);
    setStatus(String(e?.message||e||"Error"));
  }
}

// wire buttons
document.getElementById("btn-generate")?.addEventListener("click", generateReport);
document.getElementById("btn-copy")?.addEventListener("click", async ()=>{
  const t = [$p1.textContent.trim(), $p2.textContent.trim()].filter(Boolean).join("\n\n");
  try{ await navigator.clipboard.writeText(t); setStatus("Copied."); setTimeout(()=>setStatus(""),1200);}catch{ setStatus("Copy failed."); }
});

// auto-run once
generateReport();
</script>

</body>
</html>
