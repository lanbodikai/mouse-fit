<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mouse-Fit — Measurement Report</title>

<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@500;700&family=Sora:wght@400;600;800&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/neon.css" />

<style>
:root{
  --bg:#05060a; --fg:#eaf0ff; --sub:#a6b0c8; --border:rgba(255,255,255,.10);
  --g1:#7c3aed; --g2:#22d3ee; --g3:#a78bfa;
  --neon:linear-gradient(90deg,#7c3aed 0%,#22d3ee 50%,#a78bfa 100%);
}
*{box-sizing:border-box}

/* Flexbox Layout for Sticky Footer & Navbar */
html, body { height: 100%; margin: 0; }
body {
  display: flex;
  flex-direction: column;
  font-family: 'Lexend', 'Sora', system-ui, Arial;
  background:
    radial-gradient(1150px 620px at 90% 6%, rgba(48,124,255,.18), transparent 60%),
    linear-gradient(135deg,var(--bg) 0%, #071022 58%, #0a1c3a 100%);
  color: var(--fg);
  background-attachment: fixed;
}

/* Navbar container */
#nav-react { flex: 0 0 auto; z-index: 1000; position: relative; }
.nav-placeholder{
  min-height:72px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:24px;
  padding:16px 28px;
  border:1px solid rgba(255,255,255,.08);
  border-radius:18px;
  background:rgba(8,12,24,.65);
  backdrop-filter:blur(16px);
  color:#fff;
  margin:12px auto;
  max-width:1200px;
}
.nav-placeholder__logo{
  font-weight:800;
  letter-spacing:0.18em;
  font-size:.95rem;
}
.nav-placeholder__links{
  display:flex;
  gap:16px;
  flex-wrap:wrap;
  font-size:.9rem;
  color:rgba(255,255,255,.7);
}
.nav-placeholder__hint{
  font-size:.85rem;
  color:rgba(255,255,255,.6);
}

/* Main Content Wrapper */
.main-content { flex: 1 0 auto; width: 100%; }

/* ===== HERO layout ===== */
.hero{
  max-width:1200px; margin:24px auto 0; padding:0 20px;
  display:grid; grid-template-columns: minmax(280px,520px) 1fr; gap:28px; align-items:center;
  position:relative;
}
@media (max-width:980px){ .hero{grid-template-columns:1fr; gap:18px} }

.blob{
  aspect-ratio: 4/3; border-radius:18px; position:relative; overflow:hidden;
  border:1px solid rgba(255,255,255,.08);
  background:
    radial-gradient(120% 120% at 20% 10%, rgba(124,58,237,.45), transparent 40%),
    radial-gradient(80% 80% at 80% 20%, rgba(34,211,238,.35), transparent 45%),
    radial-gradient(100% 120% at 60% 80%, rgba(167,139,250,.35), transparent 55%),
    #0b0f1c;
  box-shadow: 0 30px 80px rgba(0,0,0,.45), inset 0 0 60px rgba(255,255,255,.05);
}
.blob::after{
  content:""; position:absolute; inset:0;
  background: radial-gradient(120% 120% at 30% 20%, rgba(255,255,255,.12), transparent 55%);
  mix-blend-mode: screen; pointer-events:none;
}

/* snapshot sits above blob */
#snapshot{
  position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
  display:block; transition:filter .3s ease, opacity .3s ease;
}

/* Right text block */
.report-copy{ position:relative; padding:8px 6px 8px 6px }
.h1{ font-size:28px; margin:8px 0 8px; font-weight: 700; }
.kicker{ letter-spacing:.16em; font-size:12px; opacity:.9; color:#cfe1ff; margin-bottom:8px; text-transform: uppercase; font-weight: 700; }
.ghost{
  position:absolute; right:6px; top:-6px; font-size:96px; line-height:1;
  color:transparent; -webkit-text-stroke:1px rgba(255,255,255,.06);
  text-stroke:1px rgba(255,255,255,.06); pointer-events:none; user-select:none;
}
.stats{  margin-top:8px; display:grid; gap:6px; transition:filter .25s ease, opacity .25s ease; }
.stats .row{ display:flex; gap:10px; align-items:center; font-size:14px }
.pill{padding:6px 10px;border-radius:999px;background:#0f1524;border:1px solid #2a2f40;font-size:12px;color:#cfe9f6}

/* Grip thumbs */
.grip-thumbs{display:none; gap:10px; margin-top:12px}
.grip-thumbs img{width:84px;height:56px;object-fit:cover;border-radius:8px;border:1px solid #2a2f40;background:#0b0b0f;transition:filter .25s ease}

/* Action buttons */
.btn{background:#101626;color:var(--fg);border:1px solid #223049;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
.btn.neon{background:linear-gradient(90deg,var(--g1),var(--g2),var(--g3));border-color:transparent;box-shadow:0 0 18px rgba(124,58,237,.35),0 0 28px rgba(34,211,238,.22)}
.btn.neon:hover{filter:brightness(1.05)}
.reveal-bar{ display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap }

/* Reveal/Hide blur states */
body[data-revealed="false"] #snapshot{ filter:blur(18px) saturate(.9) }
body[data-revealed="true"]  #snapshot{ filter:none }
body[data-revealed="false"] .stats,
body[data-revealed="false"] .grip-thumbs img{ filter:blur(12px) }
body[data-revealed="true"]  .stats,
body[data-revealed="true"]  .grip-thumbs img{ filter:none }

/* ===== AI REPORT SECTION ===== */
.ai-wrap{ max-width:1200px; margin:30px auto 90px; padding:0 20px }
.ai-title{ font-size:22px; margin:10px 0 6px; font-weight: 700; }
.ai-sub{ color:var(--sub); margin:0 0 10px; font-size:13px }
.controls{ display:flex; gap:10px; flex-wrap:wrap; margin: 10px 0 6px; }
.status{ font-size:12px; color:var(--sub); min-height:18px; white-space:pre-wrap }

.ai-card{
  margin-top: 14px; border: 1px solid var(--border); border-radius: 14px;
  padding: 14px; background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.04));
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
}
.ai-card h3{ margin:0 0 6px; font-size:18px; font-weight: 700; }
.para{ white-space: pre-wrap; line-height: 1.5; }
.hr{ height:1px; background: var(--border); margin: 10px 0; opacity:.7; }

.grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(230px,1fr)); gap:12px; margin-top:12px }
.chip{
  position:relative; overflow:hidden;
  border:1px solid rgba(255,255,255,.14); border-radius:16px; padding:12px 14px;
  font-weight:700; color:#fff; min-height:78px; background: rgba(255,255,255,.06);
}
.chip > *{ position:relative; z-index:1 }
.chip .meta{ font-weight:600; color:var(--sub); margin-top:6px; font-size: 12px; }
.chip .pct{ position:absolute; right:10px; top:10px; font-weight:800; font-size: 14px; }

.bg-palm::before, .bg-claw::before, .bg-tip::before{
  content:""; position:absolute; inset:0; opacity:.5; z-index:0; pointer-events:none;
}
.bg-palm::before { background: linear-gradient(135deg, rgba(82,0,163,1), rgba(167,94,246,1)); }
.bg-claw::before { background: linear-gradient(135deg, rgba(14,98,255,1), rgba(104,169,255,1)); }
.bg-tip::before  { background: linear-gradient(135deg, rgba(214,31,105,1), rgba(255,139,197,1)); }

/* Footer */
.foot { flex-shrink: 0; padding: 20px; text-align: center; font-size: 12px; color: var(--sub); }

/* Mobile */
@media (max-width: 720px){
  .hero{ max-width: 100%; margin: 16px auto 0; padding: 0 12px; grid-template-columns: 1fr; gap: 12px }
  .blob{ aspect-ratio: 3 / 2; }
  .report-copy{ padding: 4px 2px 8px 2px }
  .h1{ font-size: 22px; }
  .stats .row{ font-size: 13px }
  .reveal-bar{ gap:8px }
  .reveal-bar .btn{ flex:1 1 auto; min-width: 140px }
  .ai-wrap{ margin: 20px auto 60px; padding: 0 12px }
}
</style>
</head>
<body data-revealed="false">

  <div id="nav-react">
    <div class="nav-placeholder">
      <div class="nav-placeholder__logo">MOUSE-FIT</div>
      <div class="nav-placeholder__links">
        <span>Measure</span>
        <span>Grip</span>
        <span>AI</span>
        <span>Database</span>
      </div>
      <div class="nav-placeholder__hint">Navigation loads here.</div>
    </div>
  </div>

  <div class="main-content">
    <section class="hero">
      <div class="blob">
        <img id="snapshot" alt="Hand snapshot">
      </div>

      <div class="report-copy">
        <div class="ghost">REPORT</div>
        <div class="kicker">YOUR RESULTS</div>
        <div class="h1">Hand measurement & grip insight</div>

        <div class="stats" id="measurements">
          <div class="row"><strong>Hand length:</strong> <span id="handLength">—</span> cm</div>
          <div class="row"><strong>Palm width:</strong> <span id="handWidth">—</span> cm</div>
          <div class="row"><strong>Hand size category:</strong> <span id="handSize">—</span></div>
          <div class="row"><strong>Suggested grip style(s):</strong> <span id="suggestedGrip">—</span></div>
          <div class="row"><span id="gripPill" class="pill">Grip: not checked</span></div>
        </div>

        <div id="gripThumbs" class="grip-thumbs">
          <img id="gripTop"   alt="Top view">
          <img id="gripRight" alt="Right view">
          <img id="gripLeft"  alt="Left view">
        </div>

        <div class="reveal-bar">
          <button id="toggleReveal" class="btn neon">Reveal measurements</button>
          <a href="./grip.html" class="btn neon">Open Grip Checker</a>
          <button id="redoBtn" class="btn neon" onclick="location.href='measure.html'">Redo test</button>
        </div>
      </div>
    </section>

    <section class="ai-wrap">
      <div class="ai-title">AI Recommendations</div>
      <p class="ai-sub">Ranked per grip based on your measurements & our RAG-augmented matching rules.</p>

      <div class="controls">
        <button class="btn neon" id="btn-generate">Generate AI Report</button>
        <button class="btn" id="btn-copy">Copy Summary</button>
      </div>
      <div class="status" id="status"></div>

      <div class="ai-card">
        <h3>Two-Paragraph Summary</h3>
        <div id="p1" class="para"></div>
        <div class="hr"></div>
        <div id="p2" class="para"></div>
      </div>

      <div class="ai-card">
        <h3>Palm Grip</h3>
        <div id="grid-palm" class="grid"></div>
      </div>

      <div class="ai-card">
        <h3>Claw Grip</h3>
        <div id="grid-claw" class="grid"></div>
      </div>

      <div class="ai-card">
        <h3>Fingertip Grip</h3>
        <div id="grid-tip" class="grid"></div>
      </div>
    </section>
  </div>

  <footer class="foot">
    <div class="foot-inner"><span>© <span id="y"></span> Mouse-Fit</span></div>
  </footer>

<script>
  document.getElementById('y').textContent = new Date().getFullYear();

  /* ============================================================
     COMPAT SHIM: read either mousefit:* or mf:* keys and normalize
  ============================================================ */
  function getFirst(keys){ for (const k of keys){ const v=localStorage.getItem(k) || sessionStorage.getItem(k); if(v!=null && v!=="") return v; } return null; }
  function getJSON(keys){ const raw=getFirst(keys); if(!raw) return null; try{return JSON.parse(raw);}catch{return null;} }
  
  function normalizeMeasure(m){
    if(!m) return {};
    const len_mm = m.len_mm ?? m.length_mm ?? (m.len_cm ? Math.round(Number(m.len_cm)*10) : undefined);
    const wid_mm = m.wid_mm ?? m.width_mm ?? (m.wid_cm ? Math.round(Number(m.wid_cm)*10) : undefined);
    const out = { ...m };
    if(len_mm!=null){ out.len_mm=Number(len_mm); out.len_cm=(Number(len_mm)/10).toFixed(1); }
    if(wid_mm!=null){ out.wid_mm=Number(wid_mm); out.wid_cm=(Number(wid_mm)/10).toFixed(1); }
    return out;
  }

  const MF = {
    measure: normalizeMeasure(getJSON(['mousefit:measure','mf:measure'])),
    recs:    getJSON(['mousefit:recs','mf:recs']) || {},
    snapshot:getFirst(['mousefit:snapshot','mf:snapshot']),
    grips: {
      top:   getFirst(['mousefit:grip_view_top','mf:grip_view_top']),
      right: getFirst(['mousefit:grip_view_right','mf:grip_view_right']),
      left:  getFirst(['mousefit:grip_view_left','mf:grip_view_left']),
      result:getJSON(['mousefit:grip_result','mf:grip_result']) || {}
    }
  };
  
  // Make global for the module script below
  window.MF = MF;

  /* ============================================================
     REVEAL / HIDE (blur by default with persistence)
  ============================================================ */
  (function restoreRevealToggle(){
    const REVEAL_KEY = 'mousefit:revealed';
    const btn = document.getElementById('toggleReveal');
    if (!btn) return;

    const setReveal = (flag) => {
      document.body.setAttribute('data-revealed', flag ? 'true' : 'false');
      btn.textContent = flag ? 'Hide measurements' : 'Reveal measurements';
      try { localStorage.setItem(REVEAL_KEY, flag ? '1' : '0'); } catch {}
    };

    let initial = false;
    try { initial = localStorage.getItem(REVEAL_KEY) === '1'; } catch {}
    setReveal(initial);

    btn.addEventListener('click', () => {
      const current = document.body.getAttribute('data-revealed') === 'true';
      setReveal(!current);
    });
  })();

  /* ============================================================
     RENDER SNAPSHOT + NUMBERS + GRIP
  ============================================================ */
  (function render(){
    // snapshot
    const img = document.getElementById('snapshot');
    if (MF.snapshot) img.src = MF.snapshot; else img.style.opacity = '0';

    // numbers
    const m = MF.measure || {};
    if (m.len_cm) document.getElementById('handLength').textContent = m.len_cm;
    if (m.wid_cm) document.getElementById('handWidth').textContent  = m.wid_cm;

    const rec = MF.recs || {};
    if (rec.size) document.getElementById('handSize').textContent = rec.size;
    let gripSuggestion = "";
    const size = rec.size;
    if (size === "small") gripSuggestion = "Claw often works well for small hands; palm can also be comfy.";
    else if (size === "medium") gripSuggestion = "Palm is versatile; try claw or fingertip based on preference.";
    else if (size === "large" || size === "xlarge") gripSuggestion = "Fingertip may feel natural; palm can still be comfortable.";
    else gripSuggestion = "Any grip style can work — pick what feels most natural.";
    document.getElementById('suggestedGrip').textContent = gripSuggestion;

    // thumbs
    if (MF.grips.top || MF.grips.right || MF.grips.left){
      const box = document.getElementById('gripThumbs'); box.style.display = 'flex';
      if (MF.grips.top)   document.getElementById('gripTop').src   = MF.grips.top;
      if (MF.grips.right) document.getElementById('gripRight').src = MF.grips.right;
      if (MF.grips.left)  document.getElementById('gripLeft').src  = MF.grips.left;
    }
    const r = MF.grips.result || {};
    const grip = (r.grip || r.local_guess?.grip || "").toLowerCase();
    const conf = Math.round(100 * (r.confidence ?? r.local_guess?.confidence ?? 0));
    if (grip) document.getElementById('gripPill').textContent = conf ? `Grip: ${grip} (${conf}%)` : `Grip: ${grip}`;
  })();
</script>

<script type="module">
  const $status = document.getElementById("status");
  const $p1 = document.getElementById("p1");
  const $p2 = document.getElementById("p2");
  const setStatus = (m)=>($status.textContent = m || "");

  // ---- profile from page ----
  function scrapeProfileFromPage(){
    const mmTextToMm = (txt) => {
      const t = String(txt||"").toLowerCase();
      let m = t.match(/(\d+(?:\.\d+)?)\s*mm\b/); if (m) return +m[1];
      m = t.match(/(\d+(?:\.\d+)?)\s*cm\b/); if (m) return Math.round(+m[1]*10);
      m = t.match(/(\d+(?:\.\d+)?)/); if (!m) return undefined;
      const v = +m[1]; return v>=30 ? v : Math.round(v*10);
    };

    const profile = {};
    try {
      const ms = window.MF?.measure;
      if (ms?.len_mm) profile.length_mm = +ms.len_mm;
      if (ms?.wid_mm) profile.width_mm  = +ms.wid_mm;
    } catch {}
    
    // Fallback to reading DOM if MF obj isn't perfect
    if (!profile.length_mm) profile.length_mm = mmTextToMm(document.getElementById("handLength")?.textContent);
    if (!profile.width_mm)  profile.width_mm  = mmTextToMm(document.getElementById("handWidth")?.textContent);

    const g = window.MF?.grips?.result?.grip;
    if (g) profile.grip = String(g).toLowerCase();

    return profile;
  }

  const profile = scrapeProfileFromPage();
  let handLength = profile.length_mm || 180;
  let handWidth  = profile.width_mm  || 90;

  // ---- pull mice from ../js/mice.js ----
  async function loadMice(){
    try{
      // Dynamically import to ensure we get the data
      const mod = await import("../js/mice.js");
      if (Array.isArray(mod.MICE)) return mod.MICE;
      if (Array.isArray(mod.mice)) return mod.mice;
      if (Array.isArray(mod.default)) return mod.default;
    }catch(e){
      console.warn("Mice import failed", e);
    }
    // fallback to global if already loaded via script tag
    return window.MICE || window.mice || [];
  }

  // ---- normalize mice ----
  const toName = (m)=> m.name || [m.brand||m.make||m.maker||"", m.model||m.title||""].filter(Boolean).join(" ").trim() || "Unknown";
  const getDims = (m)=>{
    let L = m.length ?? m.length_mm ?? m.L ?? m.dimL;
    let W = m.width  ?? m.width_mm  ?? m.W ?? m.dimW;
    let H = m.height ?? m.height_mm ?? m.H ?? m.dimH;
    if ((!L || !W || !H) && m.spec){
      const dm = String(m.spec).match(/(\d+(?:\.\d+)?)\s*[×x]\s*(\d+(?:\.\d+)?)\s*[×x]\s*(\d+(?:\.\d+)?)/);
      if (dm){ L=+dm[1]; W=+dm[2]; H=+dm[3]; }
    }
    return { L:+L||0, W:+W||0, H:+H||0 };
  };
  const getWeight = (m)=>{
    let g = m.weight ?? m.weight_g;
    if (!g && m.spec){
      const mw = String(m.spec).match(/(\d+(?:\.\d+)?)\s*g\b/i);
      if (mw) g = +mw[1];
    }
    return +g || 0;
  };
  const getShape = (m)=>{
    const s = (m.shape||m.type||"").toString().toLowerCase();
    if (s.includes("ergo")) return "ergonomic";
    if (s.includes("sym") || s.includes("ambi")) return "symmetrical";
    return s || "symmetrical";
  };
  const slug = (s)=> String(s).toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-|-$|/g,"");

  function normalize(m){
    const name = toName(m);
    const {L,W,H} = getDims(m);
    const weight = getWeight(m);
    const shape = getShape(m);
    const id = m.id || slug(name);
    return { id, name, length:L, width:W, height:H, weight, shape };
  }

  // ---- scoring (latest spec) ----
  const idealRatio = { palm: 0.70, claw: 0.62, fingertip: 0.55 };
  const weightBase = { palm: 65, claw: 65, fingertip: 45 };
  const heavyKnee  = 81;

  function collectFlags(ranked){
    const map = new Map();
    for (const r of ranked||[]){
      map.set(r.id, (Array.isArray(r.flags)? r.flags.map(x=>String(x).toLowerCase()) : []));
    }
    return map;
  }
  const hasAny = (flags, arr)=> arr.some(a=> flags.includes(a));

  function gripSubscore(mouse, grip){
    const Lm = mouse.length||0;
    const target = idealRatio[grip] * handLength;
    const diffMM = Math.abs(Lm - target);
    return Math.max(0, 100 - diffMM);
  }

  function weightSubscore(mouse, grip){
    const w = mouse.weight||0;
    const base = weightBase[grip];
    if (!w) return 60;
    if (w <= base) return 100;
    const over = w - base;
    const slope = (grip==="fingertip") ? 2.0 : (grip==="claw" ? 1.4 : 1.0);
    let penalty = over * slope;
    if (w > heavyKnee){
      const extra = w - heavyKnee;
      const extraSlope = (grip==="fingertip") ? 2.5 : (grip==="claw" ? 1.5 : 1.0);
      penalty += extra * extraSlope;
    }
    return Math.max(0, 100 - penalty);
  }

  function humpSubscore(mouse, grip, flags){
    const H = mouse.height||0;
    let s = 70; 
    const f = flags || [];

    const highHumpKeys = ["high_hump","tall_hump","large_hump","huge_hump"];
    const rearHumpKeys = ["rear_hump","back_hump","rear-biased","back-biased"];
    const inclinedKeys = ["inclined_side","angled_side","tilted_side"];

    const hasHigh = (f || []).some(x => highHumpKeys.includes(x));
    const hasRear = (f || []).some(x => rearHumpKeys.includes(x));

    if (grip === "palm") {
      if (H <= 40) s -= 20;
    } else if (grip==="claw"){
          if (H >= 36 && H <= 42) s += 15;
          if (H >= 42) s -= 30;
          if (hasHigh) s += 15;
          if (hasRear) s += 12;
          if (hasAny(f, inclinedKeys)) s += 3;
    } else { // fingertip
      if (H >= 40) s -= 30;
      if (H <= 36) s += 10;
      if (hasHigh) s -= 15;
      if (hasRear) s -= 8;
    }
    return Math.max(0, Math.min(100, s));
  }

  function shapePenalty(mouse, grip){
    if (grip!=="fingertip") return 0;
    return (mouse.shape==="ergonomic") ? -50 : 0;
  }

  function extraBonus(flags, grip){
    if (grip!=="claw") return 0;
    const inclinedKeys = ["inclined_side","angled_side","tilted_side"];
    return hasAny(flags||[], inclinedKeys) ? 3 : 0;
  }

  function overallScore(mouse, grip, flags){
    const gripS   = gripSubscore(mouse, grip);
    const weightS = weightSubscore(mouse, grip);
    const humpS   = humpSubscore(mouse, grip, flags);
    let total = 0.40*gripS + 0.20*weightS + 0.40*humpS;
    total += shapePenalty(mouse, grip);
    total += extraBonus(flags, grip);
    return Math.max(0, total);
  }

  async function fetchFlags(mice){
    try{
      const candidates = mice.map(m=>({ id:m.id, brand:"", model:m.name }));
      const body = { profile: { grip: profile.grip||null, length_mm: handLength, width_mm: handWidth }, candidates };
      const r = await fetch("/api/rerank", { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
      const data = await r.json();
      if (!r.ok) throw new Error(data.error || "rerank failed");
      return collectFlags(data.ranked||[]);
    }catch(e){
      console.warn("RAG flags unavailable:", e.message||e);
      return new Map();
    }
  }

  function chipClass(grip){ return grip==="palm"?"bg-palm":grip==="claw"?"bg-claw":"bg-tip"; }
  function renderGrid(el, items, grip){
    el.innerHTML = "";
    if(!items.length) { el.innerHTML = `<div style="grid-column:1/-1; opacity:0.6;">No matches found.</div>`; return; }
    items.forEach((it, idx)=>{
      const div = document.createElement("div");
      div.className = `chip ${chipClass(grip)} ${idx===0?"best":""}`;
      const shapeName = it.shape ? it.shape.charAt(0).toUpperCase()+it.shape.slice(1) : "N/A";
      div.innerHTML = `
        <div class="pct">${Math.round(it.score)}%</div>
        <div>${it.name}</div>
        <div class="meta">Weight: ${it.weight||"?"} g, Shape: ${shapeName}</div>
      `;
      el.appendChild(div);
    });
  }

  function sanitizeReport(text){
    const [a0="", b0=""] = (text||"").trim().split(/\n\s*\n/);
    const strip = s => s.split(/\n+/).filter(line=>
      !/\b(hand|palm)\s*(length|width|size)\b/i.test(line) &&
      !/\b(colorway|colorways|color|edition)\b/i.test(line)
    ).join("\n");
    return [strip(a0).trim(), strip(b0).trim()];
  }

  async function generateReport(){
    try{
      setStatus("Loading mice…");
      const baseRaw = await loadMice();
      const mice = baseRaw.map(normalize).filter(m=> m.length && m.width && m.height);
      if (!mice.length){ setStatus("No mice with dimensions found. Check mice.js"); return; }

      setStatus("Reading flags…");
      const flagMap = await fetchFlags(mice);

      setStatus("Scoring…");
      const grips = ["palm","claw","fingertip"];
      const results = {};
      for (const g of grips){
        const list = mice.map(m=>{
          const flags = flagMap.get(m.id) || [];
          return { ...m, flags, score: overallScore(m, g, flags) };
        }).sort((a,b)=> (b.score - a.score)).slice(0, 12);
        results[g] = list;
      }

      renderGrid(document.getElementById("grid-palm"), results.palm, "palm");
      renderGrid(document.getElementById("grid-claw"), results.claw, "claw");
      renderGrid(document.getElementById("grid-tip"),  results.fingertip, "fingertip");

      // Two-paragraph summary
      setStatus("Summarizing…");
      try{
        const body = { profile, candidates: mice.map(({id,name})=>({id,brand:"",model:name})) };
        const r = await fetch("/api/report",{ method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
        if(r.ok) {
             const data = await r.json();
             const [a,b] = sanitizeReport(data.report||"");
             $p1.textContent = a; $p2.textContent = b;
        } else {
             // Fallback text if API fails or isn't set up
             $p1.textContent = "Analysis complete. Review the ranked lists below for your best mouse options.";
        }
        setStatus("");
      }catch(e){
        $p1.textContent = "Analysis complete.";
        setStatus(""); 
      }
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message||e||"Error"));
    }
  }

  // Wire up buttons
  document.getElementById("btn-generate")?.addEventListener("click", generateReport);
  document.getElementById("btn-copy")?.addEventListener("click", async ()=>{
    const t = [$p1.textContent.trim(), $p2.textContent.trim()].filter(Boolean).join("\n\n");
    try{ await navigator.clipboard.writeText(t); setStatus("Copied."); setTimeout(()=>setStatus(""),1200);}catch{ setStatus("Copy failed."); }
  });
  
  // Auto-run on load
  generateReport();
</script>

<script type="module" src="/src/main.jsx"></script>
</body>
</html>
